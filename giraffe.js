// Generated by CoffeeScript 1.6.3
var auth, changeDashboard, createGraph, dashboard, dashboards, dataPoll, default_graphite_url, default_period, description, generateDataURL, generateEventsURL, generateGraphiteTargets, getTargetColor, giraffeInit, graphScaffold, graphite_url, graphs, init, metrics, period, refresh, refreshSummary, renderAt, refreshTimer, scheme, toggleCss, _avg, _formatBase1024KMGTP, _last, _max, _min, _sum,
__indexOf = [].indexOf || function(item) {
	for (var i = 0, l = this.length; i < l; i++) { 
		if (i in this && this[i] === item) 
			return i; 
		} 
	return -1;
};

giraffeInit = function (inputDashboards) {
	dashboards = inputDashboards;
	default_period = 1440;
	scheme = [    '#848f39',
	              '#a2b73c',
	              '#ddcb53',
	              '#c5a32f',
	              '#7d5836',
	              '#963b20',
	              '#7c2626',
	              '#c80032',
	              '#6464ff'
	              ].reverse();

	refreshTimer = null;
	auth = auth != null ? auth : false;
};

custom_legendName = function() { 
	var customIntervalName;
	if(typeof period == 'undefined') {
		period = "1min";
		customIntervalName = 'Minute';
	}else{
		if(period == 60){
			customIntervalName = 'Minute';
		}else if(period == 360){
			customIntervalName = 'Five-Minutes';
		}else if(period == 1440){
			customIntervalName = 'Hour';
		}else if(period == 10080){
			customIntervalName = 'Six-Hours';
		}else if(period == 43200){
			customIntervalName = 'One-Day';
		}
   }
	return customIntervalName;
}

dataPoll = function() {
  var graph, _i, _len, _results;
  _results = [];
  $(".loadingImg").remove();
  $('.span4').prepend('<span class="loadingImg"></span>');
  $(".chart").hide();
  $(".legend").hide();
  for (_i = 0, _len = graphs.length; _i < _len; _i++) {
    graph = graphs[_i];
    _results.push(graph.refreshGraph(period));
  }
  return _results;
};

_sum = function(series) {
  return _.reduce(series, (function(memo, val) {
    return memo + val;
  }), 0);
};

_avg = function(series) {
  return _sum(series) / series.length;
};

_max = function(series) {
  return _.reduce(series, (function(memo, val) {
    if (memo === null) {
      return val;
    }
    if (val > memo) {
      return val;
    }
    return memo;
  }), null);
};

_min = function(series) {
  return _.reduce(series, (function(memo, val) {
    if (memo === null) {
      return val;
    }
    if (val < memo) {
      return val;
    }
    return memo;
  }), null);
};

_last = function(series) {
  return _.reduce(series, (function(memo, val) {
    if (val !== null) {
      return val;
    }
    return memo;
  }), null);
};

_formatBase1024KMGTP = function(y, formatter) {
  var abs_y;
  if (formatter == null) {
    formatter = d3.format(".2r");
  }
  abs_y = Math.abs(y);
  if (abs_y >= 1125899906842624) {
    return formatter(y / 1125899906842624) + "P";
  } else if (abs_y >= 1099511627776) {
    return formatter(y / 1099511627776) + "T";
  } else if (abs_y >= 1073741824) {
    return formatter(y / 1073741824) + "G";
  } else if (abs_y >= 1048576) {
    return formatter(y / 1048576) + "M";
  } else if (abs_y >= 1024) {
    return formatter(y / 1024) + "K";
  } else if (abs_y < 1 && y > 0) {
    return formatter(y);
  } else if (abs_y === 0) {
    return 0;
  } else {
    return formatter(y);
  }
};

refreshSummary = function(graph) {
  var summary_func, y_data, _ref;
  if (!((_ref = graph.args) != null ? _ref.summary : void 0)) {
    return;
  }
  if (graph.args.summary === "sum") {
    summary_func = _sum;
  }
  if (graph.args.summary === "avg") {
    summary_func = _avg;
  }
  if (graph.args.summary === "min") {
    summary_func = _min;
  }
  if (graph.args.summary === "max") {
    summary_func = _max;
  }
  if (graph.args.summary === "last") {
    summary_func = _last;
  }
  if (typeof graph.args.summary === "function") {
    summary_func = graph.args.summary;
  }
  if (!summary_func) {
    console.log("unknown summary function " + graph.args.summary);
  }
  y_data = _.map(_.flatten(_.pluck(graph.graph.series, 'data')), function(d) {
    return d.y;
  });
  return $("" + graph.args.anchor + " .graph-summary").html(graph.args.summary_formatter(summary_func(y_data)));
};

graphScaffold = function() {
  var colspan, context, converter, graph_template, i, metric, offset, _i, _len;
  graph_template = "{{#dashboard_description}}\n    <div class=\"well\">{{{dashboard_description}}}</div>\n{{/dashboard_description}}\n{{#metrics}}\n  {{#start_row}}\n  <div class=\"row-fluid \">\n  {{/start_row}}\n    <div class=\"{{span}}\" id=\"graph-{{graph_id}}\"><h2>{{metric_alias}} <span class=\"pull-right graph-summary\"><span></h2>\n      <div class=\"chart\"></div>\n      <div class=\"timeline\"></div>\n      <p>{{metric_description}}</p>\n      <div class=\"legend\"></div>\n    </div>\n  {{#end_row}}\n  </div>\n  {{/end_row}}\n{{/metrics}}";
  $(renderAt).empty();
  context = {
    metrics: []
  };
  converter = new Markdown.Converter();
  if (description) {
    context['dashboard_description'] = converter.makeHtml(description);
  }
  offset = 0;
  for (i = _i = 0, _len = metrics.length; _i < _len; i = ++_i) {
    metric = metrics[i];
    colspan = metric.colspan != null ? metric.colspan : 1;
    context['metrics'].push({
      start_row: offset % 3 === 0,
      end_row: offset % 3 === 2,
      graph_id: i,
      span: 'span' + (4 * colspan),
      metric_alias: metric.alias,
      metric_description: metric.description
    });
    offset += colspan;
  }
  return $(renderAt).append(Mustache.render(graph_template, context));
};

init = function() {
  var  i, metric, refreshInterval, _i, _j, _len, _len1;
  graphScaffold();
  $('.span4').prepend('<span class="loadingImg"></span>');
  graphs = [];
  for (i = _j = 0, _len1 = metrics.length; _j < _len1; i = ++_j) {
    metric = metrics[i];
    graphs.push(createGraph(renderAt, "#graph-" + i, metric));
  }
  refreshInterval = refresh || 10000;
  if (refreshTimer) {
    clearInterval(refreshTimer);
  }
  return refreshTimer = setInterval(dataPoll, refreshInterval);
};

renderDashboard = function(dash_name, renderAtEle, graphiteUrl) {
      graphite_url = graphiteUrl;
	  default_graphite_url = graphiteUrl;
	  dashboard = _.where(dashboards, {
	    name: dash_name
	  })[0];
	  description = dashboard['description'];
	  metrics = dashboard['metrics'];
	  refresh = dashboard['refresh'] || 300000;
	  period = default_period;
	  
	  graphs = [];
	  renderAt = renderAtEle;
      init();
};

getTargetColor = function(targets, target) {
  var t, _i, _len;
  if (typeof targets !== 'object') {
    return;
  }
  for (_i = 0, _len = targets.length; _i < _len; _i++) {
    t = targets[_i];
    if (!t.color) {
      continue;
    }
    if (t.target === target || t.alias === target) {
      return t.color;
    }
  }
};

generateGraphiteTargets = function(targets) {
  var graphite_targets, target, _i, _len;
  if (typeof targets === "string") {
    return "&target=" + targets;
  }
  if (typeof targets === "function") {
      if(targets() instanceof Array){
		  targets = targets();
	  }else{
          return "&target=" + (targets());
	  }
  }
  graphite_targets = "";
  for (_i = 0, _len = targets.length; _i < _len; _i++) {
    target = targets[_i];
    if (typeof target === "string") {
      graphite_targets += "&target=" + target;
    }
    if (typeof target === "function") {
      graphite_targets += "&target=" + (target());
    }
    if (typeof target === "object") {
      graphite_targets += "&target=" + ((target != null ? target.target : void 0) || '');
    }
  }
  return graphite_targets;
};

generateDataURL = function(targets, annotator_target, max_data_points) {
  var data_targets;
  annotator_target = annotator_target ? "&target=" + annotator_target : "";
  data_targets = generateGraphiteTargets(targets);
  return "" + graphite_url + "/render?from=-" + period + "minutes&" + data_targets + annotator_target + "&maxDataPoints=" + max_data_points + "&format=json&jsonp=?";
};

generateEventsURL = function(event_tags) {
  var jsonp, tags;
  tags = event_tags === '*' ? '' : "&tags=" + event_tags;
  jsonp = window.json_fallback ? '' : "&jsonp=?";
  return "" + graphite_url + "/events/get_data?from=-" + period + "minutes" + tags + jsonp;
};

createGraph = function(renderAt, anchorDiv, metric) {
  var anchor = renderAt + " " + anchorDiv;
  var graph, graph_provider, unstackable, _ref, _ref1, _ref2;
  graph_provider = Rickshaw.Graph.JSONP.Graphite;
  unstackable = (_ref = metric.renderer) === 'line' || _ref === 'scatterplot';
  return graph = new graph_provider({
    anchor: anchor,
    targets: metric.target || metric.targets,
    summary: metric.summary,
    summary_formatter: metric.summary_formatter | _formatBase1024KMGTP,
    totals_formatter: metric.totals_formatter || _formatBase1024KMGTP,
    totals_fields: metric.totals_fields || ["sum", "max"],
    scheme: metric.scheme || dashboard.scheme || scheme || 'munin',
    annotator_target: ((_ref1 = metric.annotator) != null ? _ref1.target : void 0) || metric.annotator,
    annotator_description: ((_ref2 = metric.annotator) != null ? _ref2.description : void 0) || 'deployment',
    events: metric.events,
    element: $("" + anchor + " .chart")[0],
    width: $("" + anchor + " .chart").width(),
    height: metric.height || 200,
    min: metric.min || 'auto',
    max: metric.max,
    padding: {top:0.03,right:0.04},
    null_as: 0,
    renderer: metric.renderer || 'line',
    interpolation: metric.interpolation || 'linear',
    unstack: metric.unstack === void 0 ? unstackable : metric.unstack,
    stroke: metric.stroke === false ? false : true,
    stroke_fn: typeof metric.stroke === "function" ? metric.stroke : void 0,
    strokeWidth: metric.stroke_width || 1.2,
    dataURL: generateDataURL(metric.target || metric.targets),
    onRefresh: function(transport) {
      return refreshSummary(transport);
    },
    onComplete: function(transport) {
      var detail, hover_formatter, shelving, xAxis, yAxis;
      graph = transport.graph;
      $(".loadingImg").remove();
      xAxis = new Rickshaw.Graph.Axis.Time({
        graph: graph
      });
      xAxis.render();
	  yAxis = new Rickshaw.Graph.Axis.Y({
	    graph: graph,
	    pixelsPerTick: 50,
	    tickFormat: metric.tick_formatter || function(y) {
	      return _formatBase1024KMGTP(y);
	    },
	    ticksTreatment: 'glow'
      });
      yAxis.render();
      hover_formatter = metric.hover_formatter || _formatBase1024KMGTP;
      detail = new Rickshaw.Graph.HoverDetail({
        graph: graph,
        yFormatter: function(y) {
          return hover_formatter(y);
        },
        formatter: function(series, x, y) {
            var swatch = '<span class="detail_swatch" style="background-color: ' + series.color + '"></span>';
            var content = swatch + series.name + '-Per-'+ custom_legendName() + ": " + parseInt(y) + '<br>';
            return content;
        }
      });
      $("" + anchor + " .legend").empty();
      this.legend = new Rickshaw.Graph.Legend({
        graph: graph,
        naturalOrder: true,
        element: $("" + anchor + " .legend")[0]
      });
      shelving = new Rickshaw.Graph.Behavior.Series.Toggle({
        graph: graph,
        legend: this.legend
      });
      if (metric.annotator || metric.events) {
        this.annotator = new GiraffeAnnotate({
          graph: graph,
          element: $("" + anchor + " .timeline")[0]
        });
      }

      return refreshSummary(this);
    }
  });
};

Rickshaw.Graph.JSONP.Graphite = Rickshaw.Class.create(Rickshaw.Graph.JSONP, {
  request: function() {
    return this.refreshGraph(period);
  },
  refreshGraph: function(period) {
    var deferred,
      _this = this;
    deferred = this.getAjaxData(period);
    return deferred.done(function(result) {
      var annotations, el, i, result_data, series, _i, _len;
      if (result.length <= 0) {
        return;
      }
      result_data = _.filter(result, function(el) {
        var _ref;
        return el.target !== ((_ref = _this.args.annotator_target) != null ? _ref.replace(/["']/g, '') : void 0);
      });
      result_data = _this.preProcess(result_data);
      if (!_this.graph) {
        _this.success(_this.parseGraphiteData(result_data, _this.args.null_as));
      }
      series = _this.parseGraphiteData(result_data, _this.args.null_as);
      if (_this.args.annotator_target) {
        annotations = _this.parseGraphiteData(_.filter(result, function(el) {
          return el.target === _this.args.annotator_target.replace(/["']/g, '');
        }), _this.args.null_as);
      }
      for (i = _i = 0, _len = series.length; _i < _len; i = ++_i) {
        el = series[i];
        _this.graph.series[i].data = el.data;
        _this.addTotals(i);
      }
      _this.graph.renderer.unstack = _this.args.unstack;
      _this.graph.render();

      _this.graph.onUpdate(function() {
	     $(".loadingImg").remove();
	     $(".chart").show();
	     $(".legend").show();
       });

      if (_this.args.events) {
        deferred = _this.getEvents(period);
        deferred.done(function(result) {
          return _this.addEventAnnotations(result);
        });
      }
      _this.addAnnotations(annotations, _this.args.annotator_description);
      return _this.args.onRefresh(_this);
    });
  },
  addTotals: function(i) {
    var avg, label, max, min, series_data, sum, totals;
    label = $(this.legend.lines[i].element).find('span.label').text();
    $(this.legend.lines[i].element).find('span.totals').remove();
    series_data = _.map(this.legend.lines[i].series.data, function(d) {
      return d.y;
    });
    sum = this.args.totals_formatter(_sum(series_data));
    max = this.args.totals_formatter(_max(series_data));
    min = this.args.totals_formatter(_min(series_data));
    avg = this.args.totals_formatter(_avg(series_data));
    totals = "<span class='totals pull-right'>";
    if (__indexOf.call(this.args.totals_fields, "sum") >= 0) {
      totals += "<span class='totalCounts'>";
      totals = totals + (" Total: " + sum);
      totals += "</span>";
    }
    if (__indexOf.call(this.args.totals_fields, "min") >= 0) {
    	totals += "<span class='totalCounts'>";
        totals = totals + (" Min: " + min);
        totals += "</span>";
    }
    if (__indexOf.call(this.args.totals_fields, "max") >= 0) {
    	totals += "<span class='totalCounts'>";
        totals = totals + (" Max: " + max);
        totals += "</span>";
    }
    if (__indexOf.call(this.args.totals_fields, "avg") >= 0) {
      totals += "<span class='totalCounts'>";
      totals = totals + ("Avg: " + avg);
      totals += "</span>";
    }
    totals += "</span>";
    return $(this.legend.lines[i].element).append(totals);
  },
  preProcess: function(result) {
    var item, _i, _len;
    for (_i = 0, _len = result.length; _i < _len; _i++) {
      item = result[_i];
      if (item.datapoints.length === 1) {
        item.datapoints[0][1] = 0;
        if (this.args.unstack) {
          item.datapoints.push([0, 1]);
        } else {
          item.datapoints.push([item.datapoints[0][0], 1]);
        }
      }
    }
    return result;
  },
  parseGraphiteData: function(d, null_as) {
    var palette, rev_xy, stroke_fn, targets;
    if (null_as == null) {
      null_as = null;
    }
    rev_xy = function(datapoints) {
      return _.map(datapoints, function(point) {
        return {
          'x': point[1],
          'y': point[0] !== null ? point[0] : null_as
        };
      });
    };
    palette = new Rickshaw.Color.Palette({
      scheme: this.args.scheme
    });
    targets = this.args.target || this.args.targets;
    stroke_fn = this.args.stroke_fn;
    d = _.map(d, function(el) {
      var color, _ref;
      if ((_ref = typeof targets) === "string" || _ref === "function") {
        color = palette.color();
      }else {
        color = getTargetColor(targets, el.target) || palette.color();
      }
      return {
        color: color,
        stroke: stroke_fn != null ? stroke_fn(d3.rgb(color)) : void 0,
        name: el.target,
        data: rev_xy(el.datapoints)
      };
    });
    Rickshaw.Series.zeroFill(d);
    return d;
  },
  addEventAnnotations: function(events_json) {
    var active_annotation, event, _i, _len, _ref, _ref1;
    if (!events_json) {
      return;
    }
    this.annotator || (this.annotator = new GiraffeAnnotate({
      graph: this.graph,
      element: $("" + this.args.anchor + " .timeline")[0]
    }));
    this.annotator.data = {};
    $(this.annotator.elements.timeline).empty();
    active_annotation = $(this.annotator.elements.timeline).parent().find('.annotation_line.active').size() > 0;
    if ((_ref = $(this.annotator.elements.timeline).parent()) != null) {
      _ref.find('.annotation_line').remove();
    }
    for (_i = 0, _len = events_json.length; _i < _len; _i++) {
      event = events_json[_i];
      this.annotator.add(event.when, "" + event.what + " " + (event.data || ''));
    }
    this.annotator.update();
    if (active_annotation) {
      return (_ref1 = $(this.annotator.elements.timeline).parent()) != null ? _ref1.find('.annotation_line').addClass('active') : void 0;
    }
  },
  addAnnotations: function(annotations, description) {
    var annotation_timestamps, _ref;
    if (!annotations) {
      return;
    }
    annotation_timestamps = _((_ref = annotations[0]) != null ? _ref.data : void 0).filter(function(el) {
      return el.y !== 0 && el.y !== null;
    });
    return this.addEventAnnotations(_.map(annotation_timestamps, function(a) {
      return {
        when: a.x,
        what: description
      };
    }));
  },
  getEvents: function(period) {
    var deferred,
      _this = this;
    this.period = period;
    return deferred = $.ajax({
      dataType: 'json',
      url: generateEventsURL(this.args.events),
      error: function(xhr, textStatus, errorThrown) {
        if (textStatus === 'parsererror' && /was not called/.test(errorThrown.message)) {
          window.json_fallback = true;
          return _this.refreshGraph(period);
        } else {
          return console.log("error loading eventsURL: " + generateEventsURL(_this.args.events));
        }
      }
    });
  },
  getAjaxData: function(period) {
    var deferred;
    this.period = period;
    return deferred = $.ajax({
      dataType: 'json',
      url: generateDataURL(this.args.targets, this.args.annotator_target, this.args.width),
      success:function(){console.log("success")},
      error: this.error.bind(this)
    });
  }
});

/* Events and interaction */

$(document).on('click', 'a.range', function() {
	  var timeFrame, _ref;
	  period = $(this).attr('data-timeframe') || default_period;
	  dataPoll();
	  $(this).parent('.btn-group').find('a').removeClass('active');
	  $(this).addClass('active');
	  return false;
});
